import {Transaction} from 'sequelize'
import {createFantoirCommune} from '@ban-team/fantoir'
import {findCodePostal} from 'codes-postaux/full.js'
import mongo from '../../util/mongo.cjs'
import {sequelize, District, CommonToponym, Address} from '../../util/sequelize.js'
import {derivePositionProps} from '../../util/geo.cjs'
import {createPseudoCodeVoieGenerator} from '../../pseudo-codes-voies.cjs'

import {formatCommonToponymDataForLegacy, formatAddressDataForLegacy, formatDistrictDataForLegacy} from './format-to-legacy-helpers.js'

// SETTINGS

// The number of records to process per page
const PAGE_SIZE = 100

// The path to the fantoir sqlite database
const FANTOIR_PATH = process.env.FANTOIR_PATH || 'data/fantoir.sqlite'

// The min and max zoom levels to use for the tiles
const TILES_ZOOM_LEVELS = {
  commonToponym: {
    min: 10,
    max: 14
  },
  address: {
    min: 12,
    max: 14
  }
}

// The buffer distance to use for the bbox calculation
const COMMON_TOPONYM_BBOX_BUFFER = 200
// For specific common toponyms (='lieu-dit'), we use a different buffer distance
const SPECIFIC_COMMON_TOPONYM_BBOX_BUFFER = 100
const ADDRESS_BBOX_BUFFER = 50

// Collections names
const EXPLOITATION_DB_COLLECTION_NAMES = {
  legacy: {
    district: 'communes_temp',
    commonToponym: 'voies_temp',
    address: 'numeros_temp'
  },
  banID: {
    district: 'district',
    commonToponym: 'common_toponym',
    address: 'address'
  }
}

// QUERIES & POSTGIS FUNCTIONS
// The queries are written in raw SQL to be able to use the PostGIS functions
// centroid: It calculates the centroid of a collection of geometries extracted from the "positions" column in the "address" table.
// bbox: It calculates a bounding box (envelope) for a collection of geometries from the "positions" column in the "address" table.
// The bbox result is transformed to a different coordinate system (2154 to 4326) and includes a buffer operation.

const commonToponymPageQuery = `
  SELECT
    CT.id, CT."districtID", CT.labels, CT.geometry, CT."updateDate", CT.meta,
    ST_Centroid(ST_Collect(ST_SetSRID(ST_GeomFromGeoJSON((A.positions[1])->'geometry'), 4326))) AS centroid,
    ST_Transform(ST_Buffer(ST_Transform(ST_Envelope(ST_Collect(ST_SetSRID(ST_GeomFromGeoJSON((A.positions[1])->'geometry'), 4326))), 2154), :addressBboxBuffer, 'join=mitre endcap=square'), 4326) AS "addressBbox",
    ST_Transform(ST_Buffer(ST_Transform(ST_Envelope(ST_SetSRID(ST_GeomFromGeoJSON(CT.geometry), 4326)), 2154), :bboxBuffer, 'join=mitre endcap=square'), 4326) AS "bbox",
    COUNT(A.id) AS "addressCount",
    COUNT(DISTINCT CASE WHEN a.certified = true THEN a.id ELSE NULL END) AS "certifiedAddressCount"
  FROM
    ban.common_toponym AS CT
  LEFT JOIN
    ban.address AS A
  ON
    CT.id = A."mainCommonToponymID"
    OR CT.id = ANY(A."secondaryCommonToponymIDs")
  WHERE CT."districtID" = :districtID
  GROUP BY CT.id
  ORDER BY CT.id ASC
  OFFSET :offset
  LIMIT :limit
`

// The queries are written in raw SQL to be able to use the PostGIS functions
// bbox: It calculates a bounding box (envelope) for the geometry contained in the "positions" column.
// The result is transformed from one coordinate system (2154) to another (4326)
// and includes a buffer operation with a distance of 50 units and specific parameters for joining and capping.
const addressPageQuery = `
  SELECT
    A.*,
    ST_Transform(ST_Buffer(ST_Transform(ST_Envelope(ST_SetSRID(ST_GeomFromGeoJSON((A.positions[1])->'geometry'), 4326)), 2154), :bboxBuffer, 'join=mitre endcap=square'), 4326) AS bbox
  FROM
    ban.address AS A
  WHERE A."districtID" = :districtID
  ORDER BY A.id ASC
  OFFSET :offset
  LIMIT :limit
`

export default async function exportToExploitationDB({data}) {
  const {districtID} = data
  console.log(`Exporting districtID ${districtID} to exploitation DB...`)

  // Use REPEATABLE_READ isolation level to balance data consistency and concurrency
  // - Ensures data consistency within each table during the transaction
  // - Allows concurrent reads across tables, minimizing read contention
  const transaction = await sequelize.transaction({
    isolationLevel: Transaction.ISOLATION_LEVELS.REPEATABLE_READ
  })

  try {
    const district = await District.findOne({
      where: {id: districtID},
      transaction,
      raw: true,
    })

    if (!district) {
      throw new Error(`District with ID ${districtID} not found.`)
    }

    // Prepare data source for calculation
    const {meta: {insee: {cog}}} = district

    // Prepare fantoir finder from cog and fantoir sqlite database
    const fantoirFinder = await createFantoirCommune(cog, {fantoirPath: FANTOIR_PATH, withAnciennesCommunes: true})

    // Prepare pseudo code voie generator from cog
    const pseudoCodeVoieGenerator = await createPseudoCodeVoieGenerator(cog)

    // Map to store the fantoir code for each common toponym to then be able to calculate the postal codes on addresses
    const commonToponymIDFantoirCodeMap = new Map()

    // Map to store the common toponym ID for each legacy common toponym ID to then be able to associate it to the legacy address
    const commonToponymIDlegacyCommonToponymIDMap = new Map()

    // Clean collections
    // Delete all data related to the district (legacy and banID)
    await deleteAllLegacyDataRelatedToCOG(cog)
    await deleteAllDataRelatedToDistrict(districtID)

    // CommonToponym
    // Count the total number of common toponyms and pages to process
    const totalCommonToponymRecords = await CommonToponym.count({
      where: {districtID},
      transaction,
    })

    const totalCommonToponymPages = Math.ceil(totalCommonToponymRecords / PAGE_SIZE)

    const fetchAndExportDataFromCommonToponymPage = async pageNumber => {
      const offset = (pageNumber - 1) * PAGE_SIZE
      const [pageData] = await sequelize.query(commonToponymPageQuery, {
        replacements: {
          districtID,
          offset,
          limit: PAGE_SIZE,
          addressBboxBuffer: COMMON_TOPONYM_BBOX_BUFFER,
          bboxBuffer: SPECIFIC_COMMON_TOPONYM_BBOX_BUFFER},
        transaction,
        raw: true,
      })
      // Format the data and calculate the fantoir code, tiles and postal code
      const pageDataWithExtraDataCalculation = pageData.map(commonToponym => calculateExtraDataForCommonToponym(commonToponym, cog, fantoirFinder, commonToponymIDFantoirCodeMap))
      const formatedPageData = pageDataWithExtraDataCalculation.map(commonToponym => formatCommonToponym(commonToponym))
      const formatedPageDataForLegacy = pageDataWithExtraDataCalculation.map(commonToponym => formatCommonToponymDataForLegacy(commonToponym, district, pseudoCodeVoieGenerator, commonToponymIDlegacyCommonToponymIDMap))

      // Insert the data in the collection (legacy and banID)
      await mongo.db.collection(EXPLOITATION_DB_COLLECTION_NAMES.legacy.commonToponym).insertMany(formatedPageDataForLegacy, {ordered: false})
      await mongo.db.collection(EXPLOITATION_DB_COLLECTION_NAMES.banID.commonToponym).insertMany(formatedPageData, {ordered: false})
    }

    const commonToponymsExportPromises = []
    for (let pageNumber = 1; pageNumber <= totalCommonToponymPages; pageNumber++) {
      commonToponymsExportPromises.push(fetchAndExportDataFromCommonToponymPage(pageNumber))
    }

    await Promise.all(commonToponymsExportPromises)

    // Address
    // Count the total number of addresses and pages to process
    const totalAddressRecords = await Address.count({
      where: {districtID},
      transaction,
    })
    const totalAddressPages = Math.ceil(totalAddressRecords / PAGE_SIZE)

    const fetchAndExportDataFromAddressPage = async pageNumber => {
      const offset = (pageNumber - 1) * PAGE_SIZE
      const [pageData] = await sequelize.query(addressPageQuery, {
        replacements: {
          districtID,
          offset,
          limit: PAGE_SIZE,
          bboxBuffer: ADDRESS_BBOX_BUFFER},
        transaction,
        raw: true,
      })

      // Format the data and calculate the fantoir code, tiles and postal code
      const pageDataWithExtraDataCalculation = pageData.map(address => calculateExtraDataForAddress(address, cog, commonToponymIDFantoirCodeMap))
      const formatedPageData = pageDataWithExtraDataCalculation.map(address => formatAddress(address))
      const formatedPageDataForLegacy = pageDataWithExtraDataCalculation.map(address => formatAddressDataForLegacy(address, district, commonToponymIDlegacyCommonToponymIDMap))

      // Insert the data in the collection (legacy and banID)
      await mongo.db.collection(EXPLOITATION_DB_COLLECTION_NAMES.legacy.address).insertMany(formatedPageDataForLegacy, {ordered: false})
      await mongo.db.collection(EXPLOITATION_DB_COLLECTION_NAMES.banID.address).insertMany(formatedPageData, {ordered: false})
    }

    const addressesExportPromises = []
    for (let pageNumber = 1; pageNumber <= totalAddressPages; pageNumber++) {
      addressesExportPromises.push(fetchAndExportDataFromAddressPage(pageNumber))
    }

    await Promise.all(addressesExportPromises)

    // District
    // For Legacy collections
    const districtFormatedForLegacy = await formatDistrictDataForLegacy(district, totalCommonToponymRecords, totalAddressRecords, transaction)
    await mongo.db.collection(EXPLOITATION_DB_COLLECTION_NAMES.legacy.district).insertOne(districtFormatedForLegacy)

    // For BanID collections
    await mongo.db.collection(EXPLOITATION_DB_COLLECTION_NAMES.banID.district).insertOne(district)

    // Pseudo code voie generator saving data
    await pseudoCodeVoieGenerator.save()

    // Commit the transaction
    await transaction.commit()
    console.log(`Exporting districtID ${districtID} done`)
  } catch (error) {
    await transaction.rollback()
    console.error(`Exporting districtID ${districtID} failed: ${error}`)
  }
}

// Helpers

// Helpers for exploitation DB
const deleteAllDataRelatedToDistrict = async districtID => {
  await Promise.all([
    mongo.db.collection(EXPLOITATION_DB_COLLECTION_NAMES.banID.district).deleteOne({districtID}),
    mongo.db.collection(EXPLOITATION_DB_COLLECTION_NAMES.banID.commonToponym).deleteMany({districtID}),
    mongo.db.collection(EXPLOITATION_DB_COLLECTION_NAMES.banID.address).deleteMany({districtID})
  ])
}

const deleteAllLegacyDataRelatedToCOG = async cog => {
  await Promise.all([
    mongo.db.collection(EXPLOITATION_DB_COLLECTION_NAMES.legacy.district).deleteOne({codeCommune: cog}),
    mongo.db.collection(EXPLOITATION_DB_COLLECTION_NAMES.legacy.commonToponym).deleteMany({codeCommune: cog}),
    mongo.db.collection(EXPLOITATION_DB_COLLECTION_NAMES.legacy.address).deleteMany({codeCommune: cog}),
  ])
}

// Helpers for formatting data
export const formatCommonToponym = commonToponym => {
  // To-do : define the format for the common toponym
  // For now, we remove data calculation used for the legacy format (centroid, addressCount, certifiedAddressCount, bbox)
  const {centroid, addressCount, certifiedAddressCount, addressBbox, bbox, ...rest} = commonToponym
  return rest
}

const formatAddress = address => {
  // To-do : define the format for the address
  // For now, we remove data calculation used for the legacy format (bbox)
  const {bbox, ...rest} = address
  return rest
}

// Helpers for calculation
export const calculateExtraDataForCommonToponym = (commonToponym, cog, fantoirFinder, commonToponymIDFantoirCodeMap) => {
  // Calculate the fantoir code for each common toponym
  const fantoirCode = calculateCommonToponymFantoirCode(commonToponymIDFantoirCodeMap, commonToponym, fantoirFinder)
  // Calculate the tiles for each common toponym
  const {geometry, tiles, x, y} = calculateCommonToponymGeometryAndTiles(commonToponym)
  // Calculate the postal code for each common toponym
  const {codePostal: postalCode, libelleAcheminement: deliveryLabel} = calculateCommonToponymPostalCode(commonToponymIDFantoirCodeMap, commonToponym, cog)
  // Remove the centroid data from the common toponym
  return {...commonToponym,
    geometry,
    meta: {
      ...commonToponym.meta,
      ...(fantoirCode ? {dgfip: {...commonToponym.meta?.dgfip, fantoir: fantoirCode}} : {}),
      ...(tiles && x && y ? {geography: {...commonToponym.meta?.geography, tiles, x, y}} : {}),
      ...(postalCode && deliveryLabel ? {laposte: {...commonToponym.meta?.laposte, codePostal: postalCode, libelleAcheminement: deliveryLabel}} : {})
    }}
}

export const calculateExtraDataForAddress = (address, cog, commonToponymIDFantoirCodeMap) => {
  // Calculate the tiles for each address
  const {tiles, x, y} = calculateAddressTiles(address)
  // Calculate the postal code for each address
  const {codePostal: postalCode, libelleAcheminement: deliveryLabel} = calculateAddressPostalCode(commonToponymIDFantoirCodeMap, address, cog)
  return {...address,
    meta: {
      ...address.meta,
      ...(tiles && x && y ? {geography: {...address.meta?.geography, tiles, x, y}} : {}),
      ...(postalCode && deliveryLabel ? {laposte: {...address.meta?.laposte, codePostal: postalCode, libelleAcheminement: deliveryLabel}} : {})
    }
  }
}

// Helpers to calculate the fantoir code
const calculateCommonToponymFantoirCode = (commonToponymIDFantoirCodeMap, commonToponym, fantoirFinder) => {
  const {meta} = commonToponym
  // Find the label in 'fra' if possible, otherwise take the first one
  const labelValue = commonToponym?.labels?.find(({isoCode}) => isoCode === 'fra')?.value || commonToponym?.labels?.[0]?.value
  const fantoirCode = calculateFantoirCode(fantoirFinder, labelValue, meta?.bal?.codeAncienneCommune)
  if (!fantoirCode) {
    return
  }

  commonToponymIDFantoirCodeMap.set(commonToponym.id, fantoirCode)
  return fantoirCode
}

const calculateFantoirCode = (fantoirFinder, labelValue, codeAncienneCommune) => {
  const fantoirData = fantoirFinder.findVoie(labelValue, codeAncienneCommune, true)
  if (!fantoirData) {
    return
  }

  // If the fantoir data is canceled and has no successor, we don't store it
  if (fantoirData.annulee && !fantoirData.successeur) {
    return
  }

  return fantoirData.successeur?.split('-')?.[1] || fantoirData.codeFantoir
}

// Helpers to calculate the postal code
const calculateCommonToponymPostalCode = (commonToponymIDFantoirCodeMap, commonToponym, cog) => {
  const fantoirCode = commonToponymIDFantoirCodeMap.get(commonToponym.id)
  const {codePostal, libelleAcheminement} = findCodePostal(cog, fantoirCode)
  return {codePostal, libelleAcheminement}
}

const calculateAddressPostalCode = (commonToponymIDFantoirCodeMap, address, cog) => {
  const fantoirCode = commonToponymIDFantoirCodeMap.get(address.mainCommonToponymID)
  const {number, suffix} = address
  const {codePostal, libelleAcheminement} = findCodePostal(cog, fantoirCode, number, suffix)
  return {codePostal, libelleAcheminement}
}

// Helpers to calculate the tiles
const calculateCommonToponymGeometryAndTiles = commonToponym => {
  const {geometry: geometryFromCommonToponym, centroid} = commonToponym
  let geometryFromCentroid
  if (centroid) {
    geometryFromCentroid = {
      type: centroid.type,
      coordinates: centroid.coordinates
    }
  }

  const geometry = geometryFromCommonToponym || geometryFromCentroid
  if (!geometry) {
    return {}
  }

  const {tiles, x, y} = derivePositionProps(geometry, TILES_ZOOM_LEVELS.commonToponym.min, TILES_ZOOM_LEVELS.commonToponym.max)
  return {geometry, tiles, x, y}
}

const calculateAddressTiles = address => {
  const {positions} = address
  const {tiles, x, y} = derivePositionProps(positions?.[0].geometry, TILES_ZOOM_LEVELS.address.min, TILES_ZOOM_LEVELS.address.max)
  return {tiles, x, y}
}
