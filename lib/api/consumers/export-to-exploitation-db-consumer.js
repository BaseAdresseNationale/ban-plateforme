import {Transaction} from 'sequelize'
import Bluebird from 'bluebird'
import {createFantoirCommune} from '@ban-team/fantoir'
import {findCodePostal} from 'codes-postaux/full.js'
import mongo from '../../util/mongo.cjs'
import {sequelize, District, CommonToponym} from '../../util/sequelize.js'
import {derivePositionProps} from '../../util/geo.cjs'
import {createPseudoCodeVoieGenerator} from '../../pseudo-codes-voies.cjs'
import gazetteerPromise from '../../util/gazetteer.cjs'

import {createCommonToponymTempTableQuery, createAddressTempTableQuery, countQuery, pageQuery, specificCommonToponymTempTableCountQuery, addressCertifiedTempTableCountQuery} from './sql-queries.js'
import {formatCommonToponymDataForLegacy, formatAddressDataForLegacy, formatDistrictDataForLegacy} from './format-to-legacy-helpers.js'
// Json contenant les communes qui changent de chefs lieux en 2025
import dirty_fix from './../../../dataset/dirty-fix-postal-code-cog2025.json' assert { type: 'json' }

// SETTINGS

// The number of records to process per page
const PAGE_SIZE = 100

// The path to the fantoir sqlite database
const FANTOIR_PATH = process.env.FANTOIR_PATH || 'data/fantoir.sqlite'

// The min and max zoom levels to use for the tiles
const TILES_ZOOM_LEVELS = {
  commonToponym: {
    min: 10,
    max: 14
  },
  address: {
    min: 12,
    max: 14
  }
}

// Collections names
const EXPLOITATION_DB_COLLECTION_NAMES = {
  district: 'communes',
  commonToponym: 'voies',
  address: 'numeros'
}

export default async function exportToExploitationDB({data}) {
  const {districtID} = data
  console.log(`Exporting districtID ${districtID} to exploitation DB...`)

  // Use REPEATABLE_READ isolation level to balance data consistency and concurrency
  // - Ensures data consistency within each table during the transaction
  // - Allows concurrent reads across tables, minimizing read contention
  const transaction = await sequelize.transaction({
    isolationLevel: Transaction.ISOLATION_LEVELS.REPEATABLE_READ
  })

  try {
    const district = await District.findOne({
      where: {id: districtID},
      transaction,
      raw: true,
    })

    if (!district) {
      throw new Error(`District with ID ${districtID} not found.`)
    }

    // Prepare data source for calculation
    const {meta: {insee: {cog}}} = district

    // Prepare fantoir finder from cog and fantoir sqlite database
    const fantoirFinder = await createFantoirCommune(cog, {fantoirPath: FANTOIR_PATH, withAnciennesCommunes: true})

    // Prepare gazetteer finder to find the ancienne commune
    const gazetteerFinder = await gazetteerPromise

    // Prepare pseudo code voie generator from cog
    const pseudoCodeVoieGenerator = await createPseudoCodeVoieGenerator(cog)

    // Map to store the fantoir code for each common toponym to then be able to calculate the postal codes on addresses
    const commonToponymIDFantoirCodeMap = new Map()

    // Map to store the common toponym ID for each legacy common toponym ID to then be able to associate it to the legacy address
    const commonToponymLegacyIDCommonToponymIDMap = new Map()

    // Set to store the legacy common toponym ID to avoid duplicates
    const commonToponymLegacyIDSet = new Set()

    // Set to store the legacy address ID to avoid duplicates
    const addressLegacyIDSet = new Set()
    // Check if the district has data to export
    // To-fix: use the district configuration instead to check if the district has to be exported
    const totalCommonToponymRecords = await CommonToponym.count({
      where: {
        districtID,
        isActive: true
      },
      transaction,
    })

    if (!totalCommonToponymRecords) {
      console.log(`District with ID ${districtID} has no data to export.`)
      await transaction.commit()
      return
    }

    // Setting temporary tables and collections
    // Temporary table names
    const tempCommonToponymTableName = `temp_common_toponym_${cog}`
    const tempAddressTableName = `temp_address_${cog}`

    // Temporary collections names
    const tempCommonToponymCollectionName = `temp_${EXPLOITATION_DB_COLLECTION_NAMES.commonToponym}_${cog}`
    const tempAddressCollectionName = `temp_${EXPLOITATION_DB_COLLECTION_NAMES.address}_${cog}`
    const tempDistrictCollectionName = `temp_${EXPLOITATION_DB_COLLECTION_NAMES.district}_${cog}`

    // Temporary collections references
    const tempCommonToponymCollection = mongo.db.collection(tempCommonToponymCollectionName)
    const tempAddressCollection = mongo.db.collection(tempAddressCollectionName)
    const tempDistrictCollection = mongo.db.collection(tempDistrictCollectionName)

    try {
      // Drop temporary tables and collections if they exist to be sure to start from a clean state
      await deleteTempTables([tempCommonToponymTableName, tempAddressTableName])
      await deleteTempCollections([tempCommonToponymCollection, tempAddressCollection, tempDistrictCollection])

      // Create temporary tables
      await sequelize.query(
        createCommonToponymTempTableQuery(tempCommonToponymTableName),
        {
          replacements: {
            districtID
          },
          transaction,
        })

      await sequelize.query(
        createAddressTempTableQuery(tempAddressTableName),
        {
          replacements: {
            tempTable: tempAddressTableName,
            districtID
          },
          transaction,
        })

      // CommonToponym
      // Count the total number of common toponyms and pages to process
      const commonToponymTempTableCountQueryResult = await sequelize.query(
        countQuery(tempCommonToponymTableName),
        {
          type: sequelize.QueryTypes.SELECT,
          transaction,
        })

      const totalCommonToponymTempTableRecordsResult = Number(commonToponymTempTableCountQueryResult?.[0]?.count)
      const totalCommonToponymPages = Math.ceil(totalCommonToponymTempTableRecordsResult / PAGE_SIZE)

      const fetchAndExportDataFromCommonToponymPage = async pageNumber => {
        try {
          const offset = (pageNumber - 1) * PAGE_SIZE
          const pageData = await sequelize.query(
            pageQuery(tempCommonToponymTableName),
            {
              replacements: {
                offset,
                limit: PAGE_SIZE
              },
              type: sequelize.QueryTypes.SELECT,
              transaction,
            })
          // Format the data and calculate the fantoir code, tiles and postal code
          const pageDataWithExtraDataCalculation = pageData.map(commonToponym => calculateExtraDataForCommonToponym(commonToponym, cog, fantoirFinder, commonToponymIDFantoirCodeMap))
          const formatedPageDataForLegacy = await Bluebird.mapSeries(pageDataWithExtraDataCalculation,
            async commonToponym => formatCommonToponymDataForLegacy(
              commonToponym,
              {
                district,
                pseudoCodeVoieGenerator,
                commonToponymLegacyIDCommonToponymIDMap,
                commonToponymLegacyIDSet,
                gazetteerFinder
              }))

          // Insert the data in the temp collection
          await tempCommonToponymCollection.insertMany(formatedPageDataForLegacy, {ordered: false})
        } catch (error) {
          console.error(`Error exporting common toponym page ${pageNumber}: ${error.message}`)
          throw error
        }
      }

      for (let pageNumber = 1; pageNumber <= totalCommonToponymPages; pageNumber++) {
        await fetchAndExportDataFromCommonToponymPage(pageNumber) // eslint-disable-line no-await-in-loop
      }

      // Address
      // Count the total number of addresses and pages to process
      const addressTempTableCountQueryResult = await sequelize.query(
        countQuery(tempAddressTableName),
        {
          type: sequelize.QueryTypes.SELECT,
          transaction,
        })
      const totalAddressRecords = Number(addressTempTableCountQueryResult?.[0]?.count)
      const totalAddressPages = Math.ceil(totalAddressRecords / PAGE_SIZE)

      const fetchAndExportDataFromAddressPage = async pageNumber => {
        const offset = (pageNumber - 1) * PAGE_SIZE
        const pageData = await sequelize.query(
          pageQuery(tempAddressTableName),
          {
            replacements: {
              offset,
              limit: PAGE_SIZE
            },
            type: sequelize.QueryTypes.SELECT,
            transaction,
          })

        // Format the data and calculate the fantoir code, tiles and postal code
        const pageDataWithExtraDataCalculation = pageData.map(address => calculateExtraDataForAddress(address, cog, commonToponymIDFantoirCodeMap))
        const formatedPageDataForLegacy = await Bluebird.mapSeries(pageDataWithExtraDataCalculation,
          async address => formatAddressDataForLegacy(
            address,
            {
              district,
              commonToponymLegacyIDCommonToponymIDMap,
              addressLegacyIDSet,
              gazetteerFinder
            }))

        const formatedPageDataForLegacyFiltered = formatedPageDataForLegacy.filter(Boolean)
        // Insert the data in the temp collection
        tempAddressCollection.insertMany(formatedPageDataForLegacyFiltered, {ordered: false})
      }

      for (let pageNumber = 1; pageNumber <= totalAddressPages; pageNumber++) {
        await fetchAndExportDataFromAddressPage(pageNumber) // eslint-disable-line no-await-in-loop
      }

      // District
      // Count the total number of "lieu-dit" common toponym used for the district legacy format
      const specificCommonToponymTempTableCountQueryResult = await sequelize.query(
        specificCommonToponymTempTableCountQuery(tempCommonToponymTableName),
        {
          type: sequelize.QueryTypes.SELECT,
          transaction,
        })
      const totalSpecifCommonToponymRecords = Number(specificCommonToponymTempTableCountQueryResult?.[0]?.count)

      // Count the total number of certified address used for the district legacy format
      const addressCertifiedTempTableCountQueryResult = await sequelize.query(
        addressCertifiedTempTableCountQuery(tempAddressTableName),
        {
          type: sequelize.QueryTypes.SELECT,
          transaction,
        })
      const totalAddressCertifiedRecords = Number(addressCertifiedTempTableCountQueryResult?.[0]?.count)

      // Commit the transaction once the temporary tables are created
      await transaction.commit()

      // Format the district data for the legacy format
      const districtFormatedForLegacy = await formatDistrictDataForLegacy(district, {totalCommonToponymRecords, totalSpecifCommonToponymRecords, totalAddressRecords, totalAddressCertifiedRecords})

      // Insert the data in the temp collection
      await tempDistrictCollection.insertOne(districtFormatedForLegacy)

      // Pseudo code voie generator saving data
      await pseudoCodeVoieGenerator.save()

      // Clear the cache of the gazetteer
      gazetteerFinder.clearCache()

      // Drop the old data
      await deleteOldDataFromFinaleCollections(cog)

      // Merge the temporary tables into the final collections
      await mergeTempCollectionsIntoFinaleCollections(tempDistrictCollection, tempCommonToponymCollection, tempAddressCollection)

      // Drop temporary collections
      await deleteTempCollections([tempDistrictCollection, tempCommonToponymCollection, tempAddressCollection])

      // Drop temporary tables
      await deleteTempTables([tempCommonToponymTableName, tempAddressTableName])
    } catch (error) {
      await deleteTempCollections([tempDistrictCollection, tempCommonToponymCollection, tempAddressCollection])
      await deleteTempTables([tempCommonToponymTableName, tempAddressTableName])
      gazetteerFinder.clearCache()
      throw error
    }

    console.log(`Exporting districtID ${districtID} done`)
  } catch (error) {
    await transaction.rollback()
    console.error(`Exporting districtID ${districtID} failed: ${error.message}`)
    throw error
  }
}

// Helpers

// Helpers for the temporary tables and collections
const deleteOldDataFromFinaleCollections = async cog => {
  await mongo.db.collection(EXPLOITATION_DB_COLLECTION_NAMES.district).deleteOne({codeCommune: cog})
  await mongo.db.collection(EXPLOITATION_DB_COLLECTION_NAMES.commonToponym).deleteMany({codeCommune: cog})
  await mongo.db.collection(EXPLOITATION_DB_COLLECTION_NAMES.address).deleteMany({codeCommune: cog})
}

const mergeTempCollectionsIntoFinaleCollections = async (tempDistrictCollection, tempCommonToponymCollection, tempAddressCollection) => {
  const collectionsToMerge = [
    {tempCollection: tempDistrictCollection, finalCollectionName: EXPLOITATION_DB_COLLECTION_NAMES.district},
    {tempCollection: tempCommonToponymCollection, finalCollectionName: EXPLOITATION_DB_COLLECTION_NAMES.commonToponym},
    {tempCollection: tempAddressCollection, finalCollectionName: EXPLOITATION_DB_COLLECTION_NAMES.address}
  ]

  const mergeCollection = async ({tempCollection, finalCollectionName}) => {
    await tempCollection.aggregate([
      {$match: {}},
      {
        $merge: {
          into: finalCollectionName
        }
      }
    ]).toArray()
  }

  const promises = collectionsToMerge.map(collectionToMerge => mergeCollection(collectionToMerge))
  await Promise.all(promises)
}

const deleteTempCollections = async collectionReferences => {
  // Get the list of existing collections
  const existingCollections = await mongo.db.listCollections().toArray()

  // Extract the names of the existing collections
  const existingCollectionNames = new Set(existingCollections.map(collection => collection.name))

  const promises = collectionReferences.map(async collectionReference => {
    // Check if the collection exists
    if (existingCollectionNames.has(collectionReference.collectionName)) {
      // Drop the collection if it exists
      await collectionReference.drop()
    }
  })
  await Promise.all(promises)
}

const deleteTempTables = async tableNames => {
  const promises = tableNames.map(tableName => sequelize.query(`DROP TABLE IF EXISTS ${tableName}`))
  await Promise.all(promises)
}

// Helpers for calculation
export const calculateExtraDataForCommonToponym = (commonToponym, cog, fantoirFinder, commonToponymIDFantoirCodeMap) => {
  // Calculate the fantoir code for each common toponym
  const fantoirCode = calculateCommonToponymFantoirCode(commonToponymIDFantoirCodeMap, commonToponym, fantoirFinder)
  // Calculate the tiles for each common toponym
  const {geometry, tiles, x, y} = calculateCommonToponymGeometryAndTiles(commonToponym)
  // Calculate the postal code for each common toponym
  const {codePostal: postalCode, libelleAcheminement: deliveryLabel} = calculateCommonToponymPostalCode(commonToponymIDFantoirCodeMap, commonToponym, cog)
  // Remove the centroid data from the common toponym
  return {...commonToponym,
    geometry,
    meta: {
      ...commonToponym.meta,
      ...(fantoirCode ? {dgfip: {...commonToponym.meta?.dgfip, fantoir: fantoirCode}} : {}),
      ...(tiles && x && y ? {geography: {...commonToponym.meta?.geography, tiles, x, y}} : {}),
      ...(postalCode && deliveryLabel ? {laposte: {...commonToponym.meta?.laposte, codePostal: postalCode, libelleAcheminement: deliveryLabel}} : {})
    }}
}

export const calculateExtraDataForAddress = (address, cog, commonToponymIDFantoirCodeMap) => {
  // Calculate the tiles for each address
  const {tiles, x, y} = calculateAddressTiles(address)
  // Calculate the postal code for each address
  const {codePostal: postalCode, libelleAcheminement: deliveryLabel} = calculateAddressPostalCode(commonToponymIDFantoirCodeMap, address, cog)
  return {...address,
    meta: {
      ...address.meta,
      ...(tiles && x && y ? {geography: {...address.meta?.geography, tiles, x, y}} : {}),
      ...(postalCode && deliveryLabel ? {laposte: {...address.meta?.laposte, codePostal: postalCode, libelleAcheminement: deliveryLabel}} : {})
    }
  }
}

// Helpers to calculate the fantoir code
const calculateCommonToponymFantoirCode = (commonToponymIDFantoirCodeMap, commonToponym, fantoirFinder) => {
  const {meta} = commonToponym
  // Find the label in 'fra' if possible, otherwise take the first one
  const labelValue = commonToponym?.labels?.find(({isoCode}) => isoCode === 'fra')?.value || commonToponym?.labels?.[0]?.value
  const fantoirCode = calculateFantoirCode(fantoirFinder, labelValue, meta?.bal?.codeAncienneCommune)
  if (!fantoirCode) {
    return
  }

  commonToponymIDFantoirCodeMap.set(commonToponym.id, fantoirCode)
  return fantoirCode
}

const calculateFantoirCode = (fantoirFinder, labelValue, codeAncienneCommune) => {
  const fantoirData = fantoirFinder.findVoie(labelValue, codeAncienneCommune, true)
  if (!fantoirData) {
    return
  }

  // If the fantoir data is canceled and has no successor, we don't store it
  if (fantoirData.annulee && !fantoirData.successeur) {
    return
  }

  return fantoirData.successeur?.split('-')?.[1] || fantoirData.codeFantoir
}

// Helpers to calculate the postal code
const calculateCommonToponymPostalCode = (commonToponymIDFantoirCodeMap, commonToponym, cog) => {
  try {
    const fantoirCode = commonToponymIDFantoirCodeMap.get(commonToponym.id)
    let codePostal
    let libelleAcheminement
    if (commonToponym.postal_code === null || commonToponym.libelleAcheminement === null || commonToponym.source_cp === 'DGFIP') {
      ({codePostal, libelleAcheminement} = findCodePostal(cog, fantoirCode)? findCodePostal(cog, fantoirCode) : dirty_fix.dirty_fix[cog])
    } else {
      codePostal = commonToponym.postal_code
      libelleAcheminement = commonToponym.libelleAcheminement
    }

    return {codePostal, libelleAcheminement}
  } catch (error) {
    console.error('Error querying database:', error)
    throw error
  }
}

const calculateAddressPostalCode = (commonToponymIDFantoirCodeMap, address, cog) => {
  try {
    const fantoirCode = commonToponymIDFantoirCodeMap.get(address.mainCommonToponymID)
    const {number, suffix} = address
    let codePostal
    let libelleAcheminement
    if (address.postal_code === null || address.libelleAcheminement === null || address.source_cp === 'DGFIP') {
      ({codePostal, libelleAcheminement} = findCodePostal(cog, fantoirCode, number, suffix)? findCodePostal(cog, fantoirCode, number, suffix) : dirty_fix.dirty_fix[cog])
    } else {
      codePostal = address.postal_code
      libelleAcheminement = address.libelleAcheminement
    }

    return {codePostal, libelleAcheminement}
  } catch (error) {
    console.error('Error querying database:', error)
    throw error
  }
}

// Helpers to calculate the geometry and tiles
const calculateCommonToponymGeometryAndTiles = commonToponym => {
  const {geometry: geometryFromCommonToponym, centroid} = commonToponym
  let geometryFromCentroid
  if (centroid) {
    geometryFromCentroid = {
      type: centroid.type,
      coordinates: centroid.coordinates
    }
  }

  const geometry = geometryFromCommonToponym || geometryFromCentroid
  if (!geometry) {
    return {}
  }

  const {tiles, x, y} = derivePositionProps(geometry, TILES_ZOOM_LEVELS.commonToponym.min, TILES_ZOOM_LEVELS.commonToponym.max)
  return {geometry, tiles, x, y}
}

const calculateAddressTiles = address => {
  const {positions} = address
  const {tiles, x, y} = derivePositionProps(positions?.[0].geometry, TILES_ZOOM_LEVELS.address.min, TILES_ZOOM_LEVELS.address.max)
  return {tiles, x, y}
}
