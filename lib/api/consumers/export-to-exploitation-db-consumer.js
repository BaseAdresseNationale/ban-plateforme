import {Transaction} from 'sequelize'
import {createFantoirCommune} from '@ban-team/fantoir'
import {findCodePostal} from 'codes-postaux/full.js'
import mongo from '../../util/mongo.cjs'
import {sequelize, District, CommonToponym, Address} from '../../util/sequelize.js'
import {derivePositionProps} from '../../util/geo.cjs'
import {createPseudoCodeVoieGenerator} from '../../pseudo-codes-voies.cjs'

import {formatCommonToponymDataForLegacy, formatAddressDataForLegacy, formatDistrictDataForLegacy} from './format-to-legacy-helpers.js'

// SETTINGS

// The number of records to process per page
const PAGE_SIZE = 100

// The path to the fantoir sqlite database
const FANTOIR_PATH = process.env.FANTOIR_PATH || 'data/fantoir.sqlite'

// The min and max zoom levels to use for the tiles
const TILES_ZOOM_LEVELS = {
  commonToponym: {
    min: 10,
    max: 14
  },
  address: {
    min: 12,
    max: 14
  }
}

// Collections names
const EXPLOITATION_DB_COLLECTION_NAMES = {
  district: 'communes',
  commonToponym: 'voies',
  address: 'numeros'
}

// QUERIES
const commonToponymPageQuery = `
  SELECT
    CTV.*
  FROM
    ban.common_toponym_view AS CTV
  WHERE CTV."districtID" = :districtID
  OFFSET :offset
  LIMIT :limit
`
const addressPageQuery = `
  SELECT
    AV.*
  FROM
    ban.address_view AS AV
  WHERE AV."districtID" = :districtID
  OFFSET :offset
  LIMIT :limit
`

export default async function exportToExploitationDB({data}) {
  const {districtID} = data
  console.log(`Exporting districtID ${districtID} to exploitation DB...`)

  // Use REPEATABLE_READ isolation level to balance data consistency and concurrency
  // - Ensures data consistency within each table during the transaction
  // - Allows concurrent reads across tables, minimizing read contention
  const transaction = await sequelize.transaction({
    isolationLevel: Transaction.ISOLATION_LEVELS.REPEATABLE_READ
  })

  try {
    const district = await District.findOne({
      where: {id: districtID},
      transaction,
      raw: true,
    })

    if (!district) {
      throw new Error(`District with ID ${districtID} not found.`)
    }

    // Prepare data source for calculation
    const {meta: {insee: {cog}}} = district

    // Prepare fantoir finder from cog and fantoir sqlite database
    const fantoirFinder = await createFantoirCommune(cog, {fantoirPath: FANTOIR_PATH, withAnciennesCommunes: true})

    // Prepare pseudo code voie generator from cog
    const pseudoCodeVoieGenerator = await createPseudoCodeVoieGenerator(cog)

    // Map to store the fantoir code for each common toponym to then be able to calculate the postal codes on addresses
    const commonToponymIDFantoirCodeMap = new Map()

    // Map to store the common toponym ID for each legacy common toponym ID to then be able to associate it to the legacy address
    const commonToponymLegacyIDCommonToponymIDMap = new Map()

    // Set to store the legacy common toponym ID to avoid duplicates
    const commonToponymLegacyIDSet = new Set()

    // Set to store the legacy address ID to avoid duplicates
    const addressLegacyIDSet = new Set()
    // Check if the district has data to export
    // To-fix: use the district configuration instead to check if the district has to be exported
    const totalCommonToponymRecords = await CommonToponym.count({
      where: {
        districtID,
        isActive: true
      },
      transaction,
    })

    if (!totalCommonToponymRecords) {
      console.log(`District with ID ${districtID} has no data to export.`)
      await transaction.commit()
      return
    }

    // Clean collections
    // Delete all data related to the district (legacy and banID)
    await deleteAllLegacyDataRelatedToCOG(cog)

    // CommonToponym
    // Count the total number of common toponyms and pages to process
    const totalCommonToponymPages = Math.ceil(totalCommonToponymRecords / PAGE_SIZE)

    const fetchAndExportDataFromCommonToponymPage = async pageNumber => {
      const offset = (pageNumber - 1) * PAGE_SIZE
      const [pageData] = await sequelize.query(commonToponymPageQuery, {
        replacements: {
          districtID,
          offset,
          limit: PAGE_SIZE},
        transaction,
        raw: true,
      })
      // Format the data and calculate the fantoir code, tiles and postal code
      const pageDataWithExtraDataCalculation = await Promise.all(pageData.map(async commonToponym => calculateExtraDataForCommonToponym(commonToponym, cog, fantoirFinder, commonToponymIDFantoirCodeMap)))
      const formatedPageDataForLegacy = pageDataWithExtraDataCalculation.map(commonToponym => formatCommonToponymDataForLegacy(commonToponym, district, pseudoCodeVoieGenerator, commonToponymLegacyIDCommonToponymIDMap, commonToponymLegacyIDSet))

      // Insert the data in the collection (legacy and banID)
      await mongo.db.collection(EXPLOITATION_DB_COLLECTION_NAMES.commonToponym).insertMany(formatedPageDataForLegacy, {ordered: false})
    }

    const commonToponymsExportPromises = []
    for (let pageNumber = 1; pageNumber <= totalCommonToponymPages; pageNumber++) {
      commonToponymsExportPromises.push(fetchAndExportDataFromCommonToponymPage(pageNumber))
    }

    await Promise.all(commonToponymsExportPromises)

    // Address
    // Count the total number of addresses and pages to process
    const totalAddressRecords = await Address.count({
      where: {
        districtID,
        isActive: true
      },
      transaction,
    })
    const totalAddressPages = Math.ceil(totalAddressRecords / PAGE_SIZE)

    const fetchAndExportDataFromAddressPage = async pageNumber => {
      const offset = (pageNumber - 1) * PAGE_SIZE
      const [pageData] = await sequelize.query(addressPageQuery, {
        replacements: {
          districtID,
          offset,
          limit: PAGE_SIZE},
        transaction,
        raw: true,
      })

      // Format the data and calculate the fantoir code, tiles and postal code
      const pageDataWithExtraDataCalculation = await Promise.all(pageData.map(async address => calculateExtraDataForAddress(address, cog, commonToponymIDFantoirCodeMap)))
      const formatedPageDataForLegacy = pageDataWithExtraDataCalculation.map(address => formatAddressDataForLegacy(address, district, commonToponymLegacyIDCommonToponymIDMap, addressLegacyIDSet))

      // Insert the data in the collection (legacy and banID)
      await mongo.db.collection(EXPLOITATION_DB_COLLECTION_NAMES.address).insertMany(formatedPageDataForLegacy, {ordered: false})
    }

    const addressesExportPromises = []
    for (let pageNumber = 1; pageNumber <= totalAddressPages; pageNumber++) {
      addressesExportPromises.push(fetchAndExportDataFromAddressPage(pageNumber))
    }

    await Promise.all(addressesExportPromises)

    // District
    // For Legacy collections
    const districtFormatedForLegacy = await formatDistrictDataForLegacy(district, totalCommonToponymRecords, totalAddressRecords, transaction)
    await mongo.db.collection(EXPLOITATION_DB_COLLECTION_NAMES.district).updateOne({codeCommune: cog}, {$set: districtFormatedForLegacy}, {upsert: true})

    // Pseudo code voie generator saving data
    await pseudoCodeVoieGenerator.save()

    // Commit the transaction
    await transaction.commit()
    console.log(`Exporting districtID ${districtID} done`)
  } catch (error) {
    await transaction.rollback()
    console.error(`Exporting districtID ${districtID} failed: ${error}`)
  }
}

// Helpers

// Helpers for exploitation DB

const deleteAllLegacyDataRelatedToCOG = async cog => {
  await Promise.all([
    mongo.db.collection(EXPLOITATION_DB_COLLECTION_NAMES.commonToponym).deleteMany({codeCommune: cog}),
    mongo.db.collection(EXPLOITATION_DB_COLLECTION_NAMES.address).deleteMany({codeCommune: cog}),
  ])
}

// Helpers for calculation
export const calculateExtraDataForCommonToponym = async (commonToponym, cog, fantoirFinder, commonToponymIDFantoirCodeMap) => {
  // Calculate the fantoir code for each common toponym
  const fantoirCode = calculateCommonToponymFantoirCode(commonToponymIDFantoirCodeMap, commonToponym, fantoirFinder)
  // Calculate the tiles for each common toponym
  const {geometry, tiles, x, y} = calculateCommonToponymGeometryAndTiles(commonToponym)
  // Calculate the postal code for each common toponym
  const {codePostal: postalCode, libelleAcheminement: deliveryLabel} = await calculateCommonToponymPostalCode(commonToponymIDFantoirCodeMap, commonToponym, cog)
  // Remove the centroid data from the common toponym
  return {...commonToponym,
    geometry,
    meta: {
      ...commonToponym.meta,
      ...(fantoirCode ? {dgfip: {...commonToponym.meta?.dgfip, fantoir: fantoirCode}} : {}),
      ...(tiles && x && y ? {geography: {...commonToponym.meta?.geography, tiles, x, y}} : {}),
      ...(postalCode && deliveryLabel ? {laposte: {...commonToponym.meta?.laposte, codePostal: postalCode, libelleAcheminement: deliveryLabel}} : {})
    }}
}

export const calculateExtraDataForAddress = async (address, cog, commonToponymIDFantoirCodeMap) => {
  // Calculate the tiles for each address
  const {tiles, x, y} = calculateAddressTiles(address)
  // Calculate the postal code for each address
  const {codePostal: postalCode, libelleAcheminement: deliveryLabel} = await calculateAddressPostalCode(commonToponymIDFantoirCodeMap, address, cog)
  return {...address,
    meta: {
      ...address.meta,
      ...(tiles && x && y ? {geography: {...address.meta?.geography, tiles, x, y}} : {}),
      ...(postalCode && deliveryLabel ? {laposte: {...address.meta?.laposte, codePostal: postalCode, libelleAcheminement: deliveryLabel}} : {})
    }
  }
}

// Helpers to calculate the fantoir code
const calculateCommonToponymFantoirCode = (commonToponymIDFantoirCodeMap, commonToponym, fantoirFinder) => {
  const {meta} = commonToponym
  // Find the label in 'fra' if possible, otherwise take the first one
  const labelValue = commonToponym?.labels?.find(({isoCode}) => isoCode === 'fra')?.value || commonToponym?.labels?.[0]?.value
  const fantoirCode = calculateFantoirCode(fantoirFinder, labelValue, meta?.bal?.codeAncienneCommune)
  if (!fantoirCode) {
    return
  }

  commonToponymIDFantoirCodeMap.set(commonToponym.id, fantoirCode)
  return fantoirCode
}

const calculateFantoirCode = (fantoirFinder, labelValue, codeAncienneCommune) => {
  const fantoirData = fantoirFinder.findVoie(labelValue, codeAncienneCommune, true)
  if (!fantoirData) {
    return
  }

  // If the fantoir data is canceled and has no successor, we don't store it
  if (fantoirData.annulee && !fantoirData.successeur) {
    return
  }

  return fantoirData.successeur?.split('-')?.[1] || fantoirData.codeFantoir
}

const queryCalculateCommonToponymPostalCode = async replacements => {
  const query = `
    SELECT
      postal_code,"libelleAcheminement",source_cp
    FROM
      ban.common_toponym_view_cp
    WHERE id = :id
    LIMIT 1 
  `
  try {
    const result = await sequelize.query(query, {replacements})
    return result[0] // Assuming the first result is what you need
  } catch (error) {
    console.error('Error querying database:', error)
    throw error
  }
}

// Helpers to calculate the postal code
const calculateCommonToponymPostalCode = async (commonToponymIDFantoirCodeMap, commonToponym, cog) => {
  try {
    const result = await queryCalculateCommonToponymPostalCode({id: commonToponym.id})
    const fantoirCode = commonToponymIDFantoirCodeMap.get(commonToponym.id)
    let codePostal
    let libelleAcheminement
    if (result.length > 0) {
      const firstResult = result[0]
      if (firstResult.postal_code === null || firstResult.libelleAcheminement === null || firstResult.source_cp === 'DGFIP') {
        ({codePostal, libelleAcheminement} = findCodePostal(cog, fantoirCode))
      } else {
        codePostal = firstResult.postal_code
        libelleAcheminement = firstResult.libelleAcheminement
      }
    } else {
      ({codePostal, libelleAcheminement} = findCodePostal(cog, fantoirCode))
    }

    return {codePostal, libelleAcheminement}
  } catch (error) {
    console.error('Error querying database:', error)
    throw error
  }
}

const queryCalculateAddressPostalCode = async replacements => {
  const query = `
    SELECT
      postal_code,"libelleAcheminement",source_cp
    FROM
      ban.address_view_cp
    WHERE id = :id
    LIMIT 1 
  `
  try {
    const result = await sequelize.query(query, {replacements})
    return result[0] // Assuming the first result is what you need
  } catch (error) {
    console.error('Error querying database:', error)
    throw error
  }
}

const calculateAddressPostalCode = async (commonToponymIDFantoirCodeMap, address, cog) => {
  try {
    const result = await queryCalculateAddressPostalCode({id: address.id})
    const fantoirCode = commonToponymIDFantoirCodeMap.get(address.mainCommonToponymID)
    const {number, suffix} = address

    let codePostal
    let libelleAcheminement

    if (result.length > 0) {
      const firstResult = result[0]
      if (firstResult.postal_code === null || firstResult.libelleAcheminement === null || firstResult.source_cp === 'DGFIP') {
        ({codePostal, libelleAcheminement} = findCodePostal(cog, fantoirCode, number, suffix))
      } else {
        codePostal = firstResult.postal_code
        libelleAcheminement = firstResult.libelleAcheminement
      }
    } else {
      ({codePostal, libelleAcheminement} = findCodePostal(cog, fantoirCode, number, suffix))
    }

    return {codePostal, libelleAcheminement}
  } catch (error) {
    console.error('Error querying database:', error)
    throw error
  }
}

const calculateCommonToponymGeometryAndTiles = commonToponym => {
  const {geometry: geometryFromCommonToponym, centroid} = commonToponym
  let geometryFromCentroid
  if (centroid) {
    geometryFromCentroid = {
      type: centroid.type,
      coordinates: centroid.coordinates
    }
  }

  const geometry = geometryFromCommonToponym || geometryFromCentroid
  if (!geometry) {
    return {}
  }

  const {tiles, x, y} = derivePositionProps(geometry, TILES_ZOOM_LEVELS.commonToponym.min, TILES_ZOOM_LEVELS.commonToponym.max)
  return {geometry, tiles, x, y}
}

const calculateAddressTiles = address => {
  const {positions} = address
  const {tiles, x, y} = derivePositionProps(positions?.[0].geometry, TILES_ZOOM_LEVELS.address.min, TILES_ZOOM_LEVELS.address.max)
  return {tiles, x, y}
}
