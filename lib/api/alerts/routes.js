import 'dotenv/config.js' // eslint-disable-line import/no-unassigned-import
import express from 'express'
import {object, string, array} from 'yup'
import analyticsMiddleware from '../../middleware/analytics.js'
import auth from '../../middleware/auth.js'

import {handleAPIResponse} from '../helper.js'
import {Revision, Subscriber} from '../../util/sequelize.js'
import {getCommuneStatus, createSubscriber, sendWebhookNotifications} from './utils.js'

const app = new express.Router()
app.use(express.json())

/**
 * @swagger
 * /api/alerts/communes/{cog}/status:
 *   get:
 *     summary: Obtenir le statut d'une commune
 *     description: RÃ©cupÃ¨re les rÃ©visions rÃ©centes d'une commune
 *     tags:
 *       - ðŸš¨ Alertes & Notifications
 *     parameters:
 *       - in: path
 *         name: cog
 *         required: true
 *         schema:
 *           type: string
 *           example: "33032"
 *           pattern: '^[0-9]{5}$'
 *         description: Code commune sur 5 chiffres
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           example: 10
 *           default: 10
 *           minimum: 1
 *           maximum: 100
 *         description: Nombre de rÃ©visions rÃ©centes Ã  retourner
 *     responses:
 *       200:
 *         description: Statut de la commune rÃ©cupÃ©rÃ© avec succÃ¨s
 *       404:
 *         description: Commune non trouvÃ©e
 *       400:
 *         description: Code commune invalide
 */
app.get('/communes/:cog/status', analyticsMiddleware, async (req, res) => {
  try {
    const {cog} = req.params
    const limit = Number(req.query.limit) || 10

    if (!/^\d{5}$/.test(cog)) {
      handleAPIResponse(res, 400, 'Code commune invalide (5 chiffres requis)', {})
      return
    }

    if (limit > 100) {
      handleAPIResponse(res, 400, 'Limite maximum : 100 rÃ©visions', {})
      return
    }

    const communeStatus = await getCommuneStatus(cog, limit)

    if (!communeStatus) {
      handleAPIResponse(res, 404, 'Commune non trouvÃ©e', {})
      return
    }

    handleAPIResponse(res, 200, 'Statut commune rÃ©cupÃ©rÃ© avec succÃ¨s', communeStatus)
  } catch (error) {
    console.error('Erreur rÃ©cupÃ©ration statut commune:', error)
    handleAPIResponse(res, 500, 'Erreur interne du serveur', {})
  }
})

/**
 * @swagger
 * /api/alerts/subscribers:
 *   post:
 *     summary: CrÃ©er un abonnement aux alertes
 *     description: Permet de s'inscrire aux notifications webhook pour suivre les statuts des rÃ©visions BAL
 *     tags:
 *       - ðŸš¨ Alertes & Notifications
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - webhookUrl
 *             properties:
 *               subscriptionName:
 *                 type: string
 *                 maxLength: 255
 *                 example: "Mairie de Paris"
 *                 description: Nom ou dÃ©nomination sociale (optionnel)
 *               webhookUrl:
 *                 type: string
 *                 format: uri
 *                 example: "https://mon-service.fr/webhooks/ban-alerts"
 *                 description: URL oÃ¹ recevoir les notifications webhook
 *               districtsToFollow:
 *                 type: array
 *                 items:
 *                   type: string
 *                   pattern: '^[0-9]{5}$'
 *                 example: ["33032", "33063"]
 *                 description: Liste des codes commune Ã  suivre (vide = toutes)
 *               statusesToFollow:
 *                 type: array
 *                 items:
 *                   type: string
 *                   enum: [success, error, warning, info]
 *                 example: ["error", "warning"]
 *                 description: Types de statuts Ã  suivre
 *               createdBy:
 *                 type: string
 *                 description: sub ProConnect de l'utilisateur
 *               createdByEmail:
 *                 type: string
 *                 format: email
 *                 description: Email de l'utilisateur
 *     responses:
 *       201:
 *         description: Abonnement crÃ©Ã© avec succÃ¨s
 *       400:
 *         description: DonnÃ©es invalides
 *       401:
 *         description: Non autorisÃ©
 *       409:
 *         description: URL dÃ©jÃ  utilisÃ©e
 */
app.post('/subscribers', auth, analyticsMiddleware, async (req, res) => {
  try {
    const subscriberData = {
      subscriptionName: req.body.subscriptionName || null,
      webhookUrl: req.body.webhookUrl,
      districtsToFollow: req.body.districtsToFollow || [],
      statusesToFollow: req.body.statusesToFollow || ['error', 'warning'],
      createdBy: req.body.createdBy || null,
      createdByEmail: req.body.createdByEmail || null
    }

    // Validation mise Ã  jour
    await object({
      subscriptionName: string().max(255).nullable(),
      webhookUrl: string().url().max(500).required(),
      districtsToFollow: array().of(string().length(5)).default([]),
      statusesToFollow: array().of(string().oneOf(['success', 'error', 'warning', 'info'])).default(['error', 'warning']),
      createdBy: string().nullable(),
      createdByEmail: string().email().nullable()
    }).validate(subscriberData)
    const subscriber = await createSubscriber(subscriberData)

    handleAPIResponse(res, 201, 'Abonnement crÃ©Ã© avec succÃ¨s', {
      id: subscriber.id,
      subscriptionName: subscriber.subscriptionName,
      webhookUrl: subscriber.webhookUrl,
      isActive: subscriber.isActive,
      createdAt: subscriber.createdAt
    })
  } catch (error) {
    if (error.name === 'ValidationError') {
      handleAPIResponse(res, 400, `DonnÃ©es invalides: ${error.message}`, {})
      return
    }

    if (error.name === 'SequelizeUniqueConstraintError') {
      handleAPIResponse(res, 409, 'URL webhook dÃ©jÃ  utilisÃ©e', {})
      return
    }

    console.error('Erreur crÃ©ation abonnement:', error)
    handleAPIResponse(res, 500, 'Erreur interne du serveur', {})
  }
})

/**
 * @swagger
 * /api/alerts/subscribers:
 *   get:
 *     summary: Lister les abonnements d'un utilisateur
 *     description: RÃ©cupÃ¨re tous les abonnements crÃ©Ã©s par un utilisateur
 *     tags:
 *       - ðŸš¨ Alertes & Notifications
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: createdBy
 *         schema:
 *           type: string
 *         description: sub ProConnect pour filtrer les abonnements
 *     responses:
 *       200:
 *         description: Liste des abonnements
 *       401:
 *         description: Non autorisÃ©
 */
app.get('/subscribers', auth, analyticsMiddleware, async (req, res) => {
  try {
    const {createdBy} = req.query
    const whereClause = createdBy ? {createdBy} : {}
    const subscribers = await Subscriber.findAll({
      where: whereClause,
      attributes: [
        'id',
        'subscriptionName',
        'webhookUrl',
        'districtsToFollow',
        'statusesToFollow',
        'isActive',
        'createdBy',
        'createdByEmail',
        'createdAt'
      ],
      order: [['createdAt', 'DESC']]
    })
    handleAPIResponse(res, 200, 'Abonnements rÃ©cupÃ©rÃ©s avec succÃ¨s', {
      subscriptions: subscribers,
      total: subscribers.length
    })
  } catch {
    handleAPIResponse(res, 500, 'Erreur interne du serveur', {})
  }
})

/**
 * @swagger
 * /api/alerts/subscribers/{id}:
 *   get:
 *     summary: Consulter un abonnement
 *     description: RÃ©cupÃ¨re les dÃ©tails d'un abonnement aux alertes
 *     tags:
 *       - ðŸš¨ Alertes & Notifications
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *           format: uuid
 *     responses:
 *       200:
 *         description: Abonnement trouvÃ©
 *       404:
 *         description: Abonnement non trouvÃ©
 *   patch:
 *     summary: Modifier un abonnement
 *     description: Met Ã  jour les propriÃ©tÃ©s d'un abonnement
 *     tags:
 *       - ðŸš¨ Alertes & Notifications
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *           format: uuid
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               subscriptionName:
 *                 type: string
 *                 maxLength: 255
 *               isActive:
 *                 type: boolean
 *               statusesToFollow:
 *                 type: array
 *                 items:
 *                   type: string
 *                   enum: [success, error, warning, info]
 *               districtsToFollow:
 *                 type: array
 *                 items:
 *                   type: string
 *                   pattern: '^[0-9]{5}$'
 *     responses:
 *       200:
 *         description: Abonnement modifiÃ© avec succÃ¨s
 *       404:
 *         description: Abonnement non trouvÃ©
 *   delete:
 *     summary: Supprimer un abonnement
 *     description: Supprime un abonnement aux alertes
 *     tags:
 *       - ðŸš¨ Alertes & Notifications
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *           format: uuid
 *     responses:
 *       200:
 *         description: Abonnement supprimÃ© avec succÃ¨s
 *       401:
 *         description: Non autorisÃ©
 *       404:
 *         description: Abonnement non trouvÃ©
 */
app.get('/subscribers/:id', analyticsMiddleware, async (req, res) => {
  try {
    const {id} = req.params

    const subscriber = await Subscriber.findByPk(id, {
      attributes: [
        'id',
        'subscriptionName',
        'webhookUrl',
        'districtsToFollow',
        'statusesToFollow',
        'isActive',
        'createdBy',
        'createdByEmail',
        'createdAt'
      ]
    })

    if (!subscriber) {
      handleAPIResponse(res, 404, 'Abonnement non trouvÃ©', {})
      return
    }

    handleAPIResponse(res, 200, 'Abonnement trouvÃ©', subscriber)
  } catch (error) {
    console.error('Erreur consultation abonnement:', error)
    handleAPIResponse(res, 500, 'Erreur interne du serveur', {})
  }
})

app.patch('/subscribers/:id', auth, analyticsMiddleware, async (req, res) => {
  try {
    const {id} = req.params
    const updateData = {}

    // Champs modifiables
    if (req.body.subscriptionName !== undefined) {
      updateData.subscriptionName = req.body.subscriptionName
    }

    if (req.body.isActive !== undefined) {
      updateData.isActive = req.body.isActive
    }

    if (req.body.statusesToFollow !== undefined) {
      updateData.statusesToFollow = req.body.statusesToFollow
    }

    if (req.body.districtsToFollow !== undefined) {
      updateData.districtsToFollow = req.body.districtsToFollow
    }

    // Validation des donnÃ©es Ã  modifier
    if (Object.keys(updateData).length === 0) {
      handleAPIResponse(res, 400, 'Aucune donnÃ©e Ã  modifier', {})
      return
    }

    const [updatedRows] = await Subscriber.update(updateData, {
      where: {id},
      returning: true
    })

    if (updatedRows === 0) {
      handleAPIResponse(res, 404, 'Abonnement non trouvÃ©', {})
      return
    }

    const updatedSubscriber = await Subscriber.findByPk(id)

    handleAPIResponse(res, 200, 'Abonnement modifiÃ© avec succÃ¨s', updatedSubscriber)
  } catch (error) {
    console.error('Erreur modification abonnement:', error)
    handleAPIResponse(res, 500, 'Erreur interne du serveur', {})
  }
})

app.delete('/subscribers/:id', auth, async (req, res) => {
  try {
    const {id} = req.params

    const deletedCount = await Subscriber.destroy({
      where: {id}
    })

    if (deletedCount === 0) {
      handleAPIResponse(res, 404, 'Abonnement non trouvÃ©', {})
      return
    }

    handleAPIResponse(res, 200, 'Abonnement supprimÃ© avec succÃ¨s', {})
  } catch (error) {
    console.error('Erreur suppression abonnement:', error)
    handleAPIResponse(res, 500, 'Erreur interne du serveur', {})
  }
})

/**
 * @swagger
 * /api/alerts/revisions:
 *   post:
 *     summary: Enregistrer une nouvelle rÃ©vision (usage interne)
 *     description: API interne pour enregistrer les statuts des rÃ©visions et dÃ©clencher les notifications
 *     tags:
 *       - ðŸš¨ Alertes & Notifications
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - revisionId
 *               - cog
 *               - status
 *             properties:
 *               revisionId:
 *                 type: string
 *               cog:
 *                 type: string
 *               districtName:
 *                 type: string
 *               districtId:
 *                 type: string
 *               status:
 *                 type: string
 *                 enum: [success, error, warning, info]
 *               message:
 *                 type: string
 *     responses:
 *       201:
 *         description: RÃ©vision enregistrÃ©e et notifications envoyÃ©es
 *       400:
 *         description: DonnÃ©es invalides
 *       401:
 *         description: Non autorisÃ©
 */
app.post('/revisions', auth, async (req, res) => {
  try {
    const revisionData = {
      revisionId: req.body.revisionId,
      cog: req.body.cog,
      districtName: req.body.districtName || null,
      districtId: req.body.districtId || null,
      status: req.body.status,
      message: req.body.message || null
    }

    await object({
      revisionId: string().required(),
      cog: string().trim().length(5).required(),
      districtName: string().trim().nullable(),
      districtId: string().nullable(),
      status: string().oneOf(['success', 'error', 'warning', 'info']).required(),
      message: string().nullable()
    }).validate(revisionData)

    const revision = await Revision.create(revisionData)

    // Envoyer les notifications webhook en arriÃ¨re-plan
    setImmediate(() => {
      sendWebhookNotifications(revision).catch(error => {
        console.error('Erreur envoi notifications:', error)
      })
    })

    handleAPIResponse(res, 201, 'RÃ©vision enregistrÃ©e avec succÃ¨s', {
      id: revision.id,
      revisionId: revision.revisionId,
      status: revision.status
    })
  } catch (error) {
    if (error.name === 'ValidationError') {
      handleAPIResponse(res, 400, `DonnÃ©es invalides: ${error.message}`, {})
      return
    }

    console.error('Erreur enregistrement rÃ©vision:', error)
    handleAPIResponse(res, 500, 'Erreur interne du serveur', {})
  }
})

export default app
