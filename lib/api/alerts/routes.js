import 'dotenv/config.js'
import express from 'express'
import analyticsMiddleware from '../../middleware/analytics.js'
import auth from '../../middleware/auth.js'

import {handleAPIResponse} from '../helper.js'
import {getCommuneStatus, createSubscriber, sendWebhookNotifications} from './utils.js'
import {object, string, array} from 'yup'
import {Revision, Subscriber} from './models.js'

const app = new express.Router()
app.use(express.json())

/**
 * @swagger
 * /api/alerts/communes/{cog}/status:
 *   get:
 *     summary: Obtenir le statut d'une commune
 *     description: R√©cup√®re les r√©visions r√©centes d'une commune
 *     tags:
 *       - üö® Alertes & Notifications
 *     parameters:
 *       - in: path
 *         name: cog
 *         required: true
 *         schema:
 *           type: string
 *           example: "33032"
 *           pattern: '^[0-9]{5}$'
 *         description: Code commune sur 5 chiffres
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           example: 10
 *           default: 10
 *           minimum: 1
 *           maximum: 100
 *         description: Nombre de r√©visions r√©centes √† retourner
 *     responses:
 *       200:
 *         description: Statut de la commune r√©cup√©r√© avec succ√®s
 *       404:
 *         description: Commune non trouv√©e
 *       400:
 *         description: Code commune invalide
 */
app.get('/communes/:cog/status', analyticsMiddleware, async (req, res) => {
  try {
    const {cog} = req.params
    const limit = Number(req.query.limit) || 10

    if (!/^[0-9]{5}$/.test(cog)) {
      handleAPIResponse(res, 400, 'Code commune invalide (5 chiffres requis)', {})
      return
    }

    if (limit > 100) {
      handleAPIResponse(res, 400, 'Limite maximum : 100 r√©visions', {})
      return
    }

    const communeStatus = await getCommuneStatus(cog, limit)
    
    if (!communeStatus) {
      handleAPIResponse(res, 404, 'Commune non trouv√©e', {})
      return
    }

    handleAPIResponse(res, 200, 'Statut commune r√©cup√©r√© avec succ√®s', communeStatus)
  } catch (error) {
    console.error('Erreur r√©cup√©ration statut commune:', error)
    handleAPIResponse(res, 500, 'Erreur interne du serveur', {})
  }
})

/**
 * @swagger
 * /api/alerts/subscribers:
 *   post:
 *     summary: Cr√©er un abonnement aux alertes
 *     description: Permet de s'inscrire aux notifications webhook pour suivre les statuts des r√©visions BAL
 *     tags:
 *       - üö® Alertes & Notifications
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - webhookUrl
 *             properties:
 *               webhookUrl:
 *                 type: string
 *                 format: uri
 *                 example: "https://mon-service.fr/webhooks/ban-alerts"
 *                 description: URL o√π recevoir les notifications webhook
 *               districtsToFollow:
 *                 type: array
 *                 items:
 *                   type: string
 *                   pattern: '^[0-9]{5}$'
 *                 example: ["33032", "33063"]
 *                 description: Liste des codes commune √† suivre (vide = toutes)
 *               statusesToFollow:
 *                 type: array
 *                 items:
 *                   type: string
 *                   enum: [success, error, warning, info]
 *                 example: ["error", "warning"]
 *                 description: Types de statuts √† suivre
 *     responses:
 *       201:
 *         description: Abonnement cr√©√© avec succ√®s
 *       400:
 *         description: Donn√©es invalides
 *       401:
 *         description: Non autoris√©
 *       409:
 *         description: URL d√©j√† utilis√©e
 */
app.post('/subscribers', auth, analyticsMiddleware, async (req, res) => {
  try {
    const subscriberData = {
      webhookUrl: req.body.webhookUrl,
      districtsToFollow: req.body.districtsToFollow || [],
      statusesToFollow: req.body.statusesToFollow || ['error', 'warning']
    }
    
    await object({
      webhookUrl: string().url().max(500).required(),
      districtsToFollow: array().of(string().length(5)).default([]),
      statusesToFollow: array().of(string().oneOf(['success', 'error', 'warning', 'info'])).default(['error', 'warning'])
    }).validate(subscriberData)
    
    const subscriber = await createSubscriber(subscriberData)
    
    handleAPIResponse(res, 201, 'Abonnement cr√©√© avec succ√®s', {
      id: subscriber.id,
      webhookUrl: subscriber.webhookUrl,
      isActive: subscriber.isActive
    })
  } catch (error) {
    if (error.name === 'ValidationError') {
      handleAPIResponse(res, 400, `Donn√©es invalides: ${error.message}`, {})
      return
    }

    if (error.name === 'SequelizeUniqueConstraintError') {
      handleAPIResponse(res, 409, 'URL webhook d√©j√† utilis√©e', {})
      return
    }

    console.error('Erreur cr√©ation abonnement:', error)
    handleAPIResponse(res, 500, 'Erreur interne du serveur', {})
  }
})

/**
 * @swagger
 * /api/alerts/subscribers/{id}:
 *   get:
 *     summary: Consulter un abonnement
 *     description: R√©cup√®re les d√©tails d'un abonnement aux alertes
 *     tags:
 *       - üö® Alertes & Notifications
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *           format: uuid
 *     responses:
 *       200:
 *         description: Abonnement trouv√©
 *       404:
 *         description: Abonnement non trouv√©
 *   delete:
 *     summary: Supprimer un abonnement
 *     description: Supprime un abonnement aux alertes
 *     tags:
 *       - üö® Alertes & Notifications
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *           format: uuid
 *     responses:
 *       200:
 *         description: Abonnement supprim√© avec succ√®s
 *       401:
 *         description: Non autoris√©
 *       404:
 *         description: Abonnement non trouv√©
 */
app.get('/subscribers/:id', analyticsMiddleware, async (req, res) => {
  try {
    const {id} = req.params
    
    const subscriber = await Subscriber.findByPk(id, {
      attributes: ['id', 'webhookUrl', 'districtsToFollow', 'statusesToFollow', 'isActive', 'createdAt']
    })
    
    if (!subscriber) {
      handleAPIResponse(res, 404, 'Abonnement non trouv√©', {})
      return
    }

    handleAPIResponse(res, 200, 'Abonnement trouv√©', subscriber)
  } catch (error) {
    console.error('Erreur consultation abonnement:', error)
    handleAPIResponse(res, 500, 'Erreur interne du serveur', {})
  }
})

app.delete('/subscribers/:id', auth, async (req, res) => {
  try {
    const {id} = req.params
    
    const deletedCount = await Subscriber.destroy({
      where: {id}
    })
    
    if (deletedCount === 0) {
      handleAPIResponse(res, 404, 'Abonnement non trouv√©', {})
      return
    }

    handleAPIResponse(res, 200, 'Abonnement supprim√© avec succ√®s', {})
  } catch (error) {
    console.error('Erreur suppression abonnement:', error)
    handleAPIResponse(res, 500, 'Erreur interne du serveur', {})
  }
})

/**
 * @swagger
 * /api/alerts/revisions:
 *   post:
 *     summary: Enregistrer une nouvelle r√©vision (usage interne)
 *     description: API interne pour enregistrer les statuts des r√©visions et d√©clencher les notifications
 *     tags:
 *       - üö® Alertes & Notifications
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - revisionId
 *               - cog
 *               - status
 *             properties:
 *               revisionId:
 *                 type: string
 *               cog:
 *                 type: string
 *               districtName:
 *                 type: string
 *               districtId:
 *                 type: string
 *               status:
 *                 type: string
 *                 enum: [success, error, warning, info]
 *               message:
 *                 type: string
 *     responses:
 *       201:
 *         description: R√©vision enregistr√©e et notifications envoy√©es
 *       400:
 *         description: Donn√©es invalides
 *       401:
 *         description: Non autoris√©
 */
app.post('/revisions', auth, async (req, res) => {
  try {
    const revisionData = {
      revisionId: req.body.revisionId,
      cog: req.body.cog,
      districtName: req.body.districtName || null,
      districtId: req.body.districtId || null,
      status: req.body.status,
      message: req.body.message || null
    }
    
    await object({
      revisionId: string().required(),
      cog: string().trim().length(5).required(),
      districtName: string().trim().nullable(),
      districtId: string().nullable(),
      status: string().oneOf(['success', 'error', 'warning', 'info']).required(),
      message: string().nullable()
    }).validate(revisionData)
    
    const revision = await Revision.create(revisionData)
    
    // Envoyer les notifications webhook en arri√®re-plan
    setImmediate(() => {
      sendWebhookNotifications(revision).catch(error => {
        console.error('Erreur envoi notifications:', error)
      })
    })
    
    handleAPIResponse(res, 201, 'R√©vision enregistr√©e avec succ√®s', {
      id: revision.id,
      revisionId: revision.revisionId,
      status: revision.status
    })
  } catch (error) {
    if (error.name === 'ValidationError') {
      handleAPIResponse(res, 400, `Donn√©es invalides: ${error.message}`, {})
      return
    }

    console.error('Erreur enregistrement r√©vision:', error)
    handleAPIResponse(res, 500, 'Erreur interne du serveur', {})
  }
})

export default app